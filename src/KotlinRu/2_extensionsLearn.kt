package com.learnxinyminutes.kotlin.KotlinRu

fun main(args: Array<String>) {
    // Kotlin позволяет расширять класс путём добавления нового функционала. Не наследуясь от такого класса и не используя паттерн "Декоратор".
    // Это реализовано с помощью специальных выражений, называемых расширения. Kotlin поддерживает функции-расширения и свойства-расширения.

    // Функции-расширения
    // Ключевое слово this внутри функции-расширения соотносится с объектом расширяемого типа
    fun MutableList<Int>.swap(index1: Int, index2: Int) {
        val tmp = this[index1] // 'this' даёт ссылку на список
        this[index1] = this[index2]
        this[index2] = tmp
    }

    val l = mutableListOf(1, 2, 3)
    l.swap(0, 2) // 'this' внутри 'swap()' будет содержать значение 'l'

    // Расширение null-допустимых типов
    fun Any?.toString(): String {
        if (this == null) return "null"
        // после проверки на null, `this` автоматически приводится к не-null типу,
        // поэтому toString() обращается (ориг.: resolves) к функции-члену класса Any
        return toString()
    }

    // Расширения, объявленные как члены класса, могут иметь модификатор видимости open и быть переопределены в унаследованных классах.
    // Это означает, что диспечеризация таких функций является виртуальной по отношению к типу диспетчера приёмников, но статической по отношению к типам приёмников расширения.
    C().caller(D())   // prints "D.foo in C"
    C1().caller(D())  // prints "D.foo in C1" - диспетчер приёмников вычислен виртуально
    C().caller(D1())  // prints "D.foo in C" - приёмник расширения вычислен статически

}

// Свойства-расширения
class ExtProperty {

    // Так как расширения на самом деле не добавляют никаких членов к классам, свойство-расширение не может иметь теневого поля.
    // Вот почему запрещено использовать инициализаторы для свойств-расширений.
    // Их поведение может быть определено только явным образом, с указанием геттеров/сеттеров.
    val <T> List<T>.lastIndex: Int
        get() = size - 1

}

open class D {
}

class D1 : D() {
}

open class C {
    open fun D.foo() {
        println("D.foo in C")
    }

    open fun D1.foo() {
        println("D1.foo in C")
    }

    fun caller(d: D) {
        d.foo()   // вызов функции-расширения
    }
}

class C1 : C() {
    override fun D.foo() {
        println("D.foo in C1")
    }

    override fun D1.foo() {
        println("D1.foo in C1")
    }
}
