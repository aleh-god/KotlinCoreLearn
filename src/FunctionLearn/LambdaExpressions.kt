package functionLearn

class LambdaExpressions : FunctionLearn {
    override fun showResult() {
        // Лямбда-выражения

        // Лямбда-выражения представляют небольшие кусочки кода, которые выполняют некоторые действия.
        // Фактически лямбды преставляют сокращенную запись функций.
        // При этом лямбды могут передаваться в качестве параметра в функции.

        // Лямбда-выражения оборачиваются в фигурные скобки:
        // В данном случае лямбда сохранена в переменную hello

        val hello = {println("Лямбда-выражения")}
        hello()
        hello()
        // Также лямбда-выражение можно выполнить сразу при определении с помощью оператора run:
        run {println("лямбда-выражение можно выполнить сразу при определении с помощью оператора run")}

        // Лямбды как и функции могут принимать параметры.
        // Для передачи параметров используется стрелка ->.
        // Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки.
        val printer = {message: String -> println(message)}
        printer("Для передачи параметров используется стрелка ->")
        printer("Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки")

        // Если параметров несколько, то они передаются слева от стрелки через запятую:
        // лямбда-выражение может возвращать конкретное значение:
        val sumTest = {x:Int, y:Int -> x + y}
        var aTest = sumTest(2, 3)   // 5
        var bTest = sumTest(4, 5)   // 9
        println("a=$aTest  b=$bTest")

        // Если в лямбда-выражении надо выполнить не одно, а несколько действий, то эти действия можно размещать на отдельных строках после стрелки:
        val sum = {x:Int, y:Int ->
            val result = x + y
            println("$x + $y = $result")
            result // Если лямбда-выражение многострочное, состоит из нескольких инструкций, то возвращается то значение, которое генерируется последней инструкцией:
        }
        aTest = sum(2, 3)   // 5
        bTest = sum(4, 5)   // 9
        println("aa=$aTest  bb=$bTest")

        // Если лямбда-выражение формально не возвращает никакого результата, то фактически, как и в функциях, возвращается значение типа Unit:
        val helloUnit = { println("HelloUnit")}
        val h = helloUnit()             // h представляет тип Unit

        val printerUnit = {message: String -> println(message)}
        val p = printerUnit("WelcomeUnit")    // p представляет тип Unit

        // Тип функции
        // Для определения функций высокого порядка прежде всего необходимо представлять, что такое тип функции. Тип функции определяется следующим образом:
        // (типы_параметров) -> возвращаемый_тип

        // При определении лямбда-выражения и присвоении его переменной мы можем явным образом у этой переменной указать тип:
        val sumType: (Int, Int)-> Int = {x:Int, y: Int -> x+y}
        val printerType: (String) -> Unit = {message: String -> println(message)}

        // Если лямбда-выражение не принимает никаких параметров, то указываются пустые скобки:
                                                                                    // (типы_параметров) -> возвращаемый_тип
        val l1 : () -> String = {"Result l1: () -> String"}   // Постоянная по имени l1 у которой тип функции () -> String и присвоено значение {"hello"} - это лябда, котрая возвращает последнее значение, и это строковый литерал
        println(l1()) // выполняем лямбду сохраненную в постоянную. Результат String печатаем

        val l2 : String = {"hello"}()       // Постоянная по имени l2 тип String, которой присвоено выполнение лямбды {"hello"}, запуск через ()
        println("Result l2:String $l2")     // Лямбда возвращает в переменную l2 строку

        // Это void лямбда. Выражение формально ничего не возвращает (точнее возвращаемым типом является Unit).
        val l3 : () -> Unit = {println("Result l3: () -> Unit")}
        l3() // выполняем лямбду сохраненную в постоянную
        // val l3 : (String) -> Unit = { text -> print(text)}

        val l4 : Unit = {println("Result l4:Unit")}() // Переменная тип Unit, которой присваивают лямбду, в которой выполняется, через (), вывод на консоль текста "Result l4:Unit"

        println({"hello"}())    // лямбда {"hello"} возвращает литерал, скопки () запускают лямбду, как run
        println({"hello"})      // println выполняет .toString лямбда-метода {"hello"}

        // Передача лямбда-выражения в функцию

        // Для передачи лямбда-выражения в функцию, необходимо определить у функции параметр, тип которого соответствует типу лямбда-выражения:

    }

    // В данном случае функция action определяет три параметра.
    // Первый два параметра - числа, а третий параметр - некоторая операция, которая производится над этими числами.
    fun highOrderFunction (n1: Int, n2: Int, operation: (Int, Int)-> Int){ // Это может быть любое лямбда-выражение, которое принимает два объекта типа Int и возвращает также объект типа Int.
        val result = operation(n1, n2)     // На момент определения функции можно не знать, что это будет за операция.
        println(result)
    }

    // Возвращение функции из функции

    fun selectAction(key: Int): // Параметры функции
                (Int, Int) -> Int  // В качестве возвращаемого типа устанавливается тип другой функции
    {
        // определение возвращаемого результата
        when(key){
            1 -> return {x:Int, y: Int -> x + y} // В теле функции возвращается лямбда выражение
            2 -> return {x:Int, y: Int -> x - y}
            3 -> return {x:Int, y: Int -> x * y}
            else -> return  {x:Int, y: Int -> 0}
        }
    }

}