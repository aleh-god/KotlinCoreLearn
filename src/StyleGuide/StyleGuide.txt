Все исходные файлы должны иметь UTF-8 кодировку.

Все исходные файлы, которые содержат высокоуровневые определения классов, должны именоваться следующим образом: имя класса + расширение файла .kt

Kotlin файл .kt включает в себя:
    * Заголовок, в котором указана лицензия и авторские права (необязательно)
    * Аннотации, которые объявлены на уровне файла
    * package объявление
    * import выражения
    * высокоуровневые объявления (классы, интерфейсы, различные функции)

            !!! Заголовок !!!
Заголовок должен быть объявлен выше остальных определений с использованием многострочных комментариев.
//!Не используйте однострочные комментарии
/** !Не используйте KDoc комментарии */

/*
 * Copyright 2021 MyCompany, Inc.
 */

        !!! Аннотации, которые объявлены на уровне файла !!!
Аннотация @file, которая является use-site target должна быть помещена между заголовком и package объявлением.

@file:JvmName("Foo")

        !!! package объявление !!!
Оператор package и import никогда не переносятся и всегда размещаются на одной строке.
Выражения import группируются для классов, функций и свойств в сортированные списки.
Импорты с подстановочным знаком не разрешены:  import androidx.room.*  // так делать не нужно

package com.example.android.fragments  // переносы запрещены

import android.view.LayoutInflater // так же и здесь

        !!! высокоуровневые объявления (классы, интерфейсы, различные функции) !!!
Kotlin файл может содержать объявление одного или нескольких классов, функций, свойств или typealiasвыражений.
Контент файла должен относится к одной теме. Например у нас есть публичный класс и набор extension функций, которые выполняют некоторые операции.
Нет явного ограничения на количество и порядок содержимого файла
Файлы обычно читаются сверху вниз, поэтому верхние части кода должны помогать нам понять нижние.
Для членов класса применимы те же правила, что и для высокоуровневых определений.

        !!! Специальные символы
В исходном коде используется только ASCII горизонтальный пробельный символ (0x20).
Это означает, что:
* Все другие пробельные символы в строчных и символьных литералах должны экранироваться
* Tab символы не используются для отступов
* Для любого символа, который имеет экранированную последовательность (\b, \r, \t, \\) используется эта последовательность, а не Unicode (например: \u000a).
* Для оставшихся символов, которые не принадлежат ASCII, используется либо Unicode символ (∞), либо Unicode последовательность (\u221e).

        !!! Скобки
Скобки не требуются для when и if которые помещаются на одной строке (оператор if не имеет else ветки).
Скобки следуют стилю Кернигана и Ритчи для непустых блоков и блочных конструкций:
* Нельзя делать разрыв строки перед открывающей скобкой
* Разрыв строки после открывающей cкобки
* Разрыв строки перед закрывающей скобкой
* Разрыв строки после закрывающей скобкой только в том случае, если она заканчивает выражение или тело функции, конструктора, класса.

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
        // ...
    }
}

Пустые блоки тоже должны быть в стиле K&R.

try {
    val response = fetchDogs("https://api.dog.com/dogs")
} catch (e: Exception) {
} // OK


// название файла Utils.kt и класса:
class Utils {
}

 // Скобки не требуются для when и if которые помещаются на одной строке
 if (str.isEmpty()) return

 // В другом случае скобки обязательно требуются для if, for, when ветвлений и do и while выражений:
 when (option) {
  1..9 -> return
  0 -> return
 }

if/else выражение может быть без скобок, если помещается на одной строке:

val value = if (str.isEmpty()) 0 else 1  // OK

val value = if (str.isEmpty()) { 	// OK
	0
} else {
	1
}

С каждом новым блоком отступ увеличивается на 4 пробела.
Когда блок закрывается отступ возвращается на предыдущий уровень (это применимо и для комментариев).

            !!!Переносы
Каждое выражение разделяется переносом на новую строку (; не используется)
Строка кода имеет ограничение в 100 символов.

!Исключения:
* Строки, которые невозможно перенести (например: длинный URL)
* package и import выражения
* Команды в документации, которые можно вставить в shell

!Правила для переноса на новую строку:
* Перенос после оператора или infix функции.
* Если строка завершается следующими операторами, то перенос осуществляется вместе с ними:
* точка (.  .?)
* ссылка на член (::)
* Имя метода или конструктура находится на одной строке с открывающей скобкой
* Запятая(,)связана с элементом и не переносится
* Стрелка (->) для lambda выражений связана с аргументами

Когда сигнатура функции не помещается, объявление параметров располагается на отдельных строчках (параметры должны иметь один отступ в 4 пробела):

fun makeSomething(
  val param1: String,
  val param2: String,
  val param3: Int
) {

}

Когда функция содержит одно выражение можно сделать так:

override fun toString(): String {
	return "Hello, $name"
}

override fun toString() = "Hello, $name"

Единственный случай, когда функция-выражение может переносится - это использование специальных блочных конструкций:

fun waitMe() = runBlocking {
	delay(1000)
}

Когда инициализация свойства не помещается на одной строке можно сделать перенос после знака присваивания (=):

 val binding: ListItemBinding =
 	DataBindingUtil.inflate(inflater, R.layout.list_item, parent, false)

get и set функции должны быть на отдельной строке с обычным отступом (4 пробела):

     val items: LiveData<List<Item>>
     	get() = _items

Read-only свойства могут иметь более краткий синтаксис:

val javaExtension: String get() = "java"

            !!!Пробелы

Помимо требуемых правил для языка и литералов (строчных или символьных) одиночный ASCII пробел:

Разделяет зарезервированные слова, таких как: if, for или catch от круглой открывающей скобки:

for (i in 1..6) {
}

Разделяет любые зарезервированные слова, таких как else и catch от закрывающей фигурной скобки:

} else {
}

Ставиться перед любой открывающей фигурной скобкой:

if (items.isEmpty()) {
}

Ставиться между операндами:

val four = 2 + 2

// Это относится и к оператору лямбда выражения (->)

items.map { item -> item % 2 == 0 }

Исключение: оператор ссылка на член (::), точка (.) или range (..)

val str = Any::toString

item.toString()

for (i in 1..6) {
		println(i)
}

Перед двоеточием (:) для указания расширения базового класса или интерфейса, а также в when выражении для generic типов:

class Worker : Runnable

fun <T> min(a: T, b: T) where T : Comparable<T>

После двоеточия (:) или запятой (,)

val items = listOf(1, 2)

class Worker : Runnable

По обеим сторонам двойного слеша:

val debugging = false // отключен по умолчанию