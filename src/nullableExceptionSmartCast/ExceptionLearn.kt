package nullableExceptionSmartCast

    // Обработка исключений

    // Исключение представляет событие, которое возникает при выполнении программы и нарушает ее нормальной ход.
    // Например, при передаче файла по сети может оборваться сетевое подключение, и в результате чего может быть сгенерировано исключение.
    // Если исключение не обработано, то программа падает и прекращает свою работу. Поэтому при возникновении исключений их следует обрабатывать.
    // Для обработки исключений применяется конструкция try..catch..finally.
    // В блок try помещаются те действия, которые потенциально могут вызвать исключение (например, передача файла по сети, открытие файла и т.д.).
    // Блок catch перехватывает возникшее исключение и обрабатывает его. Блок finally выполняет некоторые завершающие действия.
    /*
    try {
        // код, генерирующий исключение
    }
    catch (e: Exception) {
        // выполняется, если только возникло исключение
        // обработка исключения
        // Можно вернуть значение
    }
    finally {
        // выполняется в любом случае
        // постобработка
    }
     */

    // После оператора catch в скобках помещается параметр, который представляет тип исключения. Из этого параметра можно получить информацию о произошедшем исключении.
    // Блок finally является необязательным, его можно опустить. Блок catch также может отсутствовать, однако обязательно должен быть блок try и как минимум один из блоков: либо catch, либо finally. Также конструкция может содержать несколько блоков catch для обработки каждого типа исключения, которое может возникнуть.
    // Блок catch выполняется, если только возникло исключение. Блок finally выполняется в любом случае, даже если нет исключения.
    // Например, при делении на ноль Kotlin генерирует исключение:
    fun main(args: Array<String>) {

        try {                            // Действие, которое может вызвать исключение, то есть операция деления, помещается в блок try.
            val x: Int = 0
            val z: Int = 0 / x
            println("z = $z")
        } catch (e: Exception) {            // В блоке catch перехватываем исключение. При этом каждое исключение имеет определенный тип. В данном случае используется общий тип исключений - класс Exception.
            println("Exception")
            println(e.message)              // Через свойство message этого класса мы можем получить собственно сообщение об исключении.
        } finally {                        // Если необходимы какие-то завершающие действия, то можно добавить блок finally
            println("Program has been finished")
        }

        // Одна программа, один код может генерировать сразу несколько исключений.
        try {
            val nums = arrayOf(1, 2, 3, 4)
            println(nums[6])
        }
        // Для обработки каждого отдельного типа исключений можно определить отдельный блок catch.
        // В начале обрабатывается исключение более частного типа - ArrayIndexOutOfBoundsException,
        catch (e: ArrayIndexOutOfBoundsException) {
            println("Out of bound of array")
        }
        // и только потом - более общего типа Exception
        catch (e: Exception) {
            println(e.message)
        }

        // Оператор throw
        // Возможно, в каких-то ситуациях мы вручную захотим генерировать исключение.
        // Для генерации исключения применяется оператор throw, после которого указывается объект исключения:

        try {
            println(factorial(-5))
        } catch (e: Exception) {
            println(e.message)
            null            // Если же произойдет исключение, тогда переменная a получает то значение, которое указано в блоке catch, то есть в данном случае значение null.
        }
    }

fun factorial(n: Int): Int {
    // Для определения объекта Exception применяется конструктор, который принимает в качестве параметра сообщение об исключении. В данном случае это текстовое сообщение
    if (n < 1) throw Exception("Input number must be more than zero") // Для генерации исключения применяется оператор throw, после которого указывается объект исключения:
    var result = 1
    for (i in 1..n)
        result *= i
    return result
}