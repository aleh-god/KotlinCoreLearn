package nullableExceptionSmartCast

fun main(args: Array<String>) {

// Встроенные методы преобразования типов

//Для преобразования данных одного типа в другой можно использовать встроенные следующие функции, которые есть у базовых типов (Int, Long, Double и т.д.):
//toByte toShort toInt toLong toFloat toDouble toChar

    val s: String = "12"
    println("String = $s")
    val d: Int = s.toInt()
    println("строка s преобразуется в число d = $d")

    // Однако надо учитывать, что значение не всегда может быть преобразовано к определенному типу. И в этом случае генерируется исключение.
    val ss: String = "tom"
    try {
        val dd: Int = ss.toInt()
        println("в таких случаях желательно отлавливать исключение: $dd")
    }
    catch(e: NumberFormatException){
        println(e.message)
    }

    // Smart cast и оператор is

    // Оператор is позволяет проверить выражение на принадлежность определенному типу данных.
    // Если локальная переменная или свойство успешно пройдет проверку на принадлежность определенному типу, то далее нет нужды дополнительно приводить значение к этому типу.
    // Данные преобразования еще называются smart casts или "умные преобразования".

    val obj : Any? = "Jesus"
    println(obj is String?) // of String or null
    println(obj is String)  // of String
    println(obj !is String) // negative
    if (obj is String && obj.length > 0) println("Смарт каст можно использовать в логических выражениях")

    squareIs(5)

    // Явные преобразования и оператор as
    // Также мы можем явным образом приводить значение одного типа к другому с помощью оператора as:

    squareAs(5)

    // Casts Приведение к типу              (лучше использовать оператор is)
    obj as String
    obj as String?
    obj as? String      // Если нельзя привести, то возвращается null

    // Однако в случае если преобразование завершится неудачно, то будет сгенерировано исключение ClassCastException.
    // Чтобы избежать выброса исключения, мы можем применять более безопасную версию оператора as?,
    // которая в случае неудачи преобразования возвращает null.

    val name : String  = "Tom"
    val id: Int? = name as? Int
    println(id)     // null

    // // Инфиксная нотация

    // Функция класса принимает один параметр - сумму, которая добавляется на счет.
    var acc = InfixLearn(340)
    // Поскольку функция put является инфиксной, то мы можем вызывать ее как обычную функцию: acc.put(300)
    acc.put(300)
    println(acc.sum)    // 640
    // А можно вызывать таким вот образом: acc put 300.
    acc put 300
    println(acc.sum)    // 940

    val resultInfix : String  = "#" addNumber 10    // #10
    println(resultInfix)

    // Функции расширения (extension function)
    // Следует учитывать, что в функциях расширения мы можем обращаться к любым общедоступным свойствам и методам
    // объекта, однако не можем обращаться к свойствам и методам с модификаторами private и protected.
    // Также следует учитывать, что функции расширения не переопределяют функции, которые уже определены в классе.
    // Если функция расширения имеет ту же сигнатуру, что и уже имеющаяся функция класса, то компилятор просто будет игнорировать подобную функцию расширения.

    // Для типа String определена функция wordCount, которая подсчитывает, сколько встречается определенный символ в строке.
    var hello: String = "hello world"
    println(hello.wordCount('l'))   // 3
    println(hello.wordCount('o'))   // 2

    // Для типа Int определена функция возведения в квадрат.
    println(4.square())                 // 16
    println(6.square())                 // 36


}

// Здесь в функции square значение параметра d с помощью оператора is проверяется на принадлежность типу Int.
fun squareIs(d: Any){
    //val t = d * d   // недопустимая операция - d - не число, а объект типа Any
    if(d is Int)      // до применения оператора is оно принадлежит типу Any. И только применение оператора is преобразует значение из типа Any в тип Int
        println(d * d)  // норм, d уже представляет тип Int
    else
        println("d is not an Int")
}

fun squareAs(d: Any){
    val t = d as Int    // явным образом приводим к типу Int
    println(t * t)
}

// Инфиксная нотация представляет помещение оператора или функции перед операндами или аргументами.
infix fun String.addNumber(a: Int): String {
    return this + a.toString()
}

// Функции расширения (extension function) позволяют добавить функционал к уже определенным типам.
/*
 fun тип.имя_функции(параметры) : возвращаемый_тип { тело функции }
  */

// По большому счету определение аналогично определению обычной функции за тем исключением,
// что после слова fun идет название типа, для которого определяется функция, и через точку название функции.

fun String.wordCount(c: Char) : Int{
    var count = 0
    for(n in 0..this.count()-1){
        if(this[n] == c) count++
    }
    return count
}

fun Int.square(): Int{
    return this * this      // Через this обращаемся к тому объекту, для которого будет вызывться функция.
}

