package collections

fun main(args: Array<String>) {

    val numbers = listOf(1, -2, 3, -4, 5, -6)     // 1
    val letters = listOf('a', 'A', 'b', 'B', 'A', 'a')

    val people = listOf(                                                     // 2
        Person("John", "Boston", 56),
        Person("Sarah", "Munich", 23),
        Person("Svyatoslav", "Saint-Petersburg", 89),
        Person("Vasilisa", "Saint-Petersburg", 56)
    )

    // Kotlin из коробки предоставляет два способа обработки данных: энергичный для Collection и ленивый для Sequence.
    // Разница между ленивыми и энергичными вычислениями в том, когда они происходят. Коллекция трансформируется энергично.
    // Каждая операция выполняется в момент вызова, а результат преобразования — новая коллекция.
    // Преобразователи коллекций — это встраиваемые функции.

    // Ниже встраиваемая функция map, создающая новый ArrayList:
    val doubled = numbers.map { x -> x * 2 }      // 2
    println(doubled)
    val tripled = numbers.map { it * 3 }          // 3
    println(tripled)

    // Последовательности вычисляются лениво. То есть имеют два типа операций: промежуточные и терминальные (прерывающие).
    // Промежуточные не выполняются сразу. Они сохраняются в список и запускаются цепочкой вместе с терминальной функцией для каждого элемента отдельно.

    //map, distinct, groupBy и т.д. — промежуточные, возвращают Sequence.

    println(letters.distinct()) // [a, KotlinRu.A, b, KotlinRu.B]
    println(numbers.map { it * it }) // [1, 4, 9]

    val words = listOf("a", "abc", "ab", "def", "abcd")

    val byLength = words.groupBy { it.length }  // Map<K, List<T>>
    println(byLength.keys) // [1, 3, 2, 4]
    println(byLength.values) // [[a], [abc, def], [ab], [abcd]]

    val peopleCities = people.groupBy(Person::lastName, Person::name)            // 5

    //first, toList, count и т.д. — терминальные, не возвращают Sequence.

    val first = numbers.toList()
    val last = numbers.last()                            // 3
    val count = numbers.count()
    val lastOdd = numbers.last { it % 2 != 0 }           // 5

    /*
    Последовательности не содержат ссылку на элементы коллекции. Они создаются на основе итератора оригинальной коллекции, и в них — ссылка на все промежуточные операции, которые должны быть выполнены.
    В отличие от трансформеров коллекций, трансформеры последовательностей не могут быть встраиваемыми функциями. Они не могут сохраняться, а последовательностям нужно именно это. Посмотрев на реализацию, мы видим, что преобразователь возвращает Sequence:

    Терминальные операции выполняются до совпадения с предикатом.

    Последовательности
    1. asSequence — последовательность создаётся на основе итератора оригинальной коллекции.
    2. map. Трансформация добавляется в список выполняемых операций, но не выполняется.
    3. first. Это терминальная операция. Значит, выполняются операции из списка выше. Обрабатываем каждый элемент начальной последовательности map и сразу же first. Условие из first выполняется уже на втором элементе.
    Не нужно обрабатывать всю последовательность!

    Порядок преобразований
    Используете вы коллекции или последовательности, порядок преобразований имеет значение. В примере выше first может не вызываться для всего списка строго после map: это не имеет значения для map. Если мы сначала вызовем коллекцию, а затем преобразуем результат, то создадим только один новый объект — жёлтый квадрат. С последовательности мы не создаём два новых объекта. С коллекциями — не создаём список.

    Терминальные операции могут закончить обработку раньше, а промежуточные последовательности вычисляются лениво. Значит, последовательности могут помочь избежать лишней работы. Всегда проверяйте порядок трансформаций!

    Операции в коллекции используют встраиваемые функции, так что байткод самих операций и лямбда‐выражений, переданных как параметры, будет встроен. Коллекции создают новый список для каждого преобразования. Последовательности же содержат ссылку на функции преобразования.
    Когда мы работаем с небольшим коллекциями и одной-двумя операциями, разница в производительности не существенна. Можно использовать коллекции. Но, когда вы работаете с большими списками, они могут стать дорогостоящими. Используйте последовательности.

     */
}
